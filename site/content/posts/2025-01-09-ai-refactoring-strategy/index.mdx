---
featured: true
title: AI 時代的舊系統重構策略
date: 2026-01-09 01:01:35 +0800
thumbnail: ai-refactoring.jpg
category: Backend
tags: ['ai', 'refactoring', 'architecture']
description: AI 時代的舊系統重構策略
author: Mark Ku
slug: ai-refactoring-strategy
---
## 前言
最近被問到這個問題，AI 時代如何重構舊系統，就順便整理起來。

## Vibe Coding 的缺點
AI 是能夠增加10倍的生產力，但也可以增加10倍的Bub 及系統複雜度，一但出事時，因為不是人寫的，可能也沒這麼好查出問題。

## 建立統一入口（前提是舊系統有 API）

所有請求不再直接打進舊系統 IP，而是**統一先走 API Gateway**。

```text
/api/v1/orders  -> 舊系統（Old System）
/api/v2/orders  -> 新微服務（New Microservice）
```

透過版本區分，把新舊系統藏在 Gateway 後面，
就能**一個 API、一個 API 地遷移**，而不是一次全部重寫，也不用一次押上所有風險。

## 整理出讓 AI 能讀懂的架構指引

重點不是文件寫多厚，而是**邏輯與結構的一致性**：

* 系統架構
* 程式碼規範及風格
* 檔名資料夾怎麼放
* 模組間的關係
* 資料流程圖
* 單元測試怎麼寫

並可以在建構時就用工具強制約束，
例如前端透過 ESLint 把程式碼風格與壞味道收斂起來，
.NET 透過 Roslyn Analyzer 搭配 `.editorconfig` 把規範寫死在建置流程裡，
AI 才不會「每次都幫你寫一種風格」，也比較能理解你真正想要的架構。

另外，關鍵的商業邏輯最好都有測試，範例要先由人把情境、input / output 整理好，再請 AI 協助產生或補齊測試，確保「同一組 input 永遠得到預期的 output」，這樣風險才會相對最低。

## 盤點重構功能，決定 AI 介入程度

先把需要重構的功能列出來，
依**容錯率**決定 AI 能走多遠：

* 高容錯：AI 可自動產生、快速迭代
* 低容錯：一定要人工驗證、人工決策

不是所有地方都適合全自動，有些地方就是要人眼一行一行看，或是人工去測試。

## 善用 AI Code Review

可以透過 AI 來進行 Code Review，讓 AI 先幫忙找問題、看風險、提建議，但**決策權永遠在工程師手上**。

## 真的出問題時，怎麼快速發現

當大多數程式碼是由 AI 產生時，團隊對系統細節的熟悉度通常不會太高。這時就得靠**錯誤狀態碼**和**埋好的 log**，來快速縮小問題範圍。

- 站台監控：`uptime-kuma`
- API 監控：`Prometheus + Grafana` 或 `Jaeger`

例如一定有即時觀測指標：
* API error rate
* latency
* 關鍵流程的 商業觀測指標

重構成不成功，告警和報表會先告訴你。

## 把 Log 當成問題定位的錨點

監控看的是「數字」，log 看的是「發生了什麼事」，兩個要一起設計：
## 把 Log 當成問題定位的錨點

Log 不是單純記一行文字，而是幫你在系統裡打很多「錨點」，出問題時可以順著這些錨點，一步一步把請求沿路走過的地方全部還原出來。

這些先想清楚、埋在架構裡，出事時才不會只有一行「Something went wrong」。

## 短時間查不出來，怎麼退

退路一定要先準備好：

* Git 直接退版
* 或在 API Gateway 切回舊系統
* k8s rollback 

能退，才敢改。

## 感想

重構的本質，是**降低系統的不確定性**，如果結構複雜也缺乏一致性，那麼原本就很亂的系統，透過AI重構，系統複雜變成放大好幾倍，真正該做的不是期待 AI 幫你重構好一切，透過AI輔助你處理協助明確的項目。

* 收斂入口
* 建立一致性
* 清楚哪些能錯、哪些不能錯
* 準備好監控與退路

當系統變得「可被理解」，不管是人，還是 AI，才真的幫得上忙。
