---
featured: true
title: AI 時代的舊系統重構翻新策略
date: 2026-01-09 01:01:35 +0800
thumbnail: ai-refactoring.jpg
category: Backend
tags: ['ai', 'refactoring', 'architecture']
description: AI 時代的舊系統重構策略
author: Mark Ku
slug: ai-refactoring-strategy
---
## 前言
最近常被問到一個問題：在 AI 時代，有許多企業都想要數位轉型，舊系統到底要怎麼重構翻新？乾脆就把這陣子的思考和做法整理成一篇文章。

## Vibe Coding 的優點及缺點
AI 的確可以將軟體生產力放大 n 倍，但同時也可能把 Bug 和系統複雜度（多出來的程式碼、過度設計）一起放大 n 倍，如果發生重大系統錯誤，最後還是得回到人類工程師來修理，而因為很多程式不是自己寫的，出問題時也沒這麼容易一眼看出到底哪裡壞掉。

## 改寫的前提 - 餘裕
以過去一次重寫系統的經驗來說，因為前後其實都是同一組人在開發，舊系統的核心功能一邊持續出問題、一邊又不斷有新需求進來，導致開發資源被來回拉扯，結果整整花了將近一年半的時間，只是在讓舊系統需求收斂及穩定，直到那個階段完成，才真正有餘裕開始談改寫。

## 需定整理
在這樣的背景下，需求整理本身就變成一個關鍵工程，而不只是開規格而已：

1. **全面盤點**
   包含沒在用到的功能、已知問題與潛在漏洞、業務端的沒被滿足清單、實際存在的使用場景、資源配額，以及各部門目前的守備範圍與責任邊界。

2. **重新設計而不是照單全收**
   針對盤點出來的項目，重新思考哪些值得留下、哪些需要調整，甚至哪些本來就不該存在、或是功能太大，需要延後滿足的。

3. **讓不確定性浮出水面**
   把原本處於 *known unknowns* 的事情主動攤開來討論，逐步轉換成已知、可掌控的風險與決策依據。

4. **必要時重新定義流程**
   有些問題的根源其實不在系統，而在工作流程本身，這時就需要有勇氣重新定義，而不是只用技術硬撐。
> P.S. 此部分感謝雷 N 大大提供的觀點與提醒

## 建立 api 統一入口（前提是舊系統有 API）

所有請求不再直接打進舊系統 IP，而是**統一先走 API Gateway**。

```text
/api/v1/orders  -> 舊系統（Old System）
/api/v2/orders  -> 新微服務（New Microservice）
```

透過版本區分，把新舊系統藏在 Gateway 後面，
就能**一個 API、一個 API 地遷移**，而不是一次全部重寫，可以逐步替代掉舊的API，未來有新舊版本管理，也會比較容易。

## 整理出讓 AI 能讀懂的架構指引

重點不是文件寫多厚，而是**邏輯與結構的一致性**：

* 系統架構
* 資料庫結構
* 程式碼規範及風格
* 檔名資料夾怎麼放
* 模組間的關係
* 資料流程圖
* 單元測試怎麼寫

並可以在建構時就用工具強制約束，
例如前端透過 ESLint 把程式碼風格與壞味道收斂起來，
.NET 透過 Roslyn Analyzer 搭配 `.editorconfig` 把規範寫死在建置流程裡，
AI 才不會「每次都幫你寫一種風格」，也比較能理解你真正想要的架構。

另外，關鍵的商業邏輯最好都有測試，範例要先由人把情境、input / output 整理好，再請 AI 協助產生或補齊測試，確保「同一組 input 永遠得到預期的 output」，這樣風險才會相對最低。

## 盤點重構功能，決定 AI 介入程度

先把需要重構的功能列出來，
依**容錯率**決定 AI 能走多遠：

* 高容錯：AI 可自動產生、快速迭代
* 低容錯：一定要人工驗證、人工去看

不是所有地方都適合全自動，有些地方就是要人眼一行一行看，或是人工去測試。

## 善用 AI Code Review

可以透過 AI 來進行 Code Review，讓 AI 先幫忙找問題、看風險、提建議，但還是要搭配人去判斷。  
ex: 像是github 搭配 copliot 就有 code review 機制。

## 真的出問題時，怎麼快速發現

當大多數程式碼是由 AI 產生時，團隊對系統細節的熟悉度通常不會太高。這時就得靠**錯誤狀態碼**和**埋好的 log**當成定位的錨點，來快速縮小問題範圍。

- 主動監控(發送request)：`uptime-kuma`
- 被動監控(有人使用，發現壞了或慢了)：`Prometheus + Grafana` 或 `Jaeger`

例如一定有即時觀測指標：
* API error rate
* latency
* 關鍵流程的 商業觀測指標

## 短時間查不出來，怎麼退

能退，才敢改。重構的過程中一定會犯錯，所以退路一定要先想好、先準備好，你會犯的錯，別人其實也很可能會犯，當真的出問題時，就把它當成機會，去優化現有的重構流程，讓整個系統一步一步持續迭代、越來越成熟。

* Git 直接退版，重新建構
* 在 API Gateway 切回舊系統
* k8s rollback 

## WinForm 到 Web 的操作體驗
WinForm 轉 Web，最大的挑戰不是技術，而是「使用者原本的操作習慣」。以前大家在 WinForm 上用 combo、快捷鍵，動作都很快、很直覺；改成 Web 之後，就要重新思考怎麼設計，讓使用起來一樣順、甚至更快。

- 快速選擇：使用 autocomplete，完整支援鍵盤操作(hot key)與焦點移動。
- 低延遲回饋：避免全頁刷新，採用局部更新與預取，提高響應速度。
- 批次與快捷鍵：保留常用快捷鍵與批次操作能力，縮短操作路徑。
- 一致語意：沿用舊系統用語與流程映射，降低學習成本。

## 響應式設計 - Mobile-first CSS 與 Tailwind
現在大部分的人都是用手機看網站，所以設計通常會先從 Mobile First 開始。這邊滿推薦用 Tailwind，因為它本來就是走 Mobile First 的設計思路，也幫你把不同裝置、不同尺寸的情境都想好了，擴充也很方便。

- 前台公開網站：先把手機版為出發點，再往桌面版加強。
- 後台系統：因為後台系統每個都做RWD，往往後台功能太多，做成手機版的開發，成本就會比較高，除非這是必要功能，其實可以考量需要的部份才做RWD。
- 桌面系統：專注於密集操作的效率，貼近使用者的操作習慣。

## 感想

重構的本質，是**降低系統的不確定性**，如果結構複雜也缺乏一致性，那麼原本就很亂的系統，透過AI重構，系統複雜變成放大好幾倍，真正該做的不是期待 AI 幫你重構好一切，透過AI輔助你處理協助明確的項目，當系統變得「可被理解」，不管是人，還是 AI，才真的幫得上忙。
