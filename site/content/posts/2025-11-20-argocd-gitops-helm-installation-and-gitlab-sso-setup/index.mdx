---
featured: true
title: 用 Argo CD 實作 GitOps：從 Helm 安裝到 GitLab SSO 一次搞定
slug: argocd-gitops-helm-installation-and-gitlab-sso-setup
category: DevOps
thumbnail: argocd-gitops-helm-installation-and-gitlab-sso-setup.png
date: 2025-11-20 10:00:00 +0800
tags: ['Kubernetes', 'Argo CD', 'GitOps', 'Helm', 'GitLab', 'DevOps']
description: 以實務步驟示範如何用 Helm 安裝 Argo CD，並結合 GitOps 與 GitLab SSO，讓多叢集 K8s 部署管理自動化又可回溯。
author: Mark Ku
---

## 前言

如果你現在手上有 **10～20 個 Kubernetes 集群** 要顧，還在那邊每一個用 kubectl 手動切 context、apply YAML，其實滿折騰的。

有點像你有 20 支手機，要裝同一個 App，結果你一支一支打開商店搜尋、下載、登入——某一天一定會漏裝、裝錯，或是少改一個設定。

**Argo CD** 搭配 **GitOps** 就是在解決這種「人手操作一定會出包」的場景。缺點是，它的學習曲線的確比單純用 kubectl 陡一點，你要先理解：

- GitOps 在講的「宣告式」跟「唯一真相來源」到底是什麼
- Argo CD 裡的 Application、Project、Sync 這些東西在玩什麼
- Helm、OAuth、Registry、RBAC 這些元件要怎麼串在一起

但一旦這些拼圖拼起來，多叢集、多環境的日常維運真的會輕鬆非常多。

---
featured: true
title: 用 Argo CD 實作 GitOps：從 Helm 安裝到 GitLab SSO 一次搞定
slug: argocd-gitops-helm-installation-and-gitlab-sso-setup
category: DevOps
thumbnail: argocd-gitops-helm-installation-and-gitlab-sso-setup.png
date: 2025-11-20 10:00:00 +0800
tags: ['Kubernetes', 'Argo CD', 'GitOps', 'Helm', 'GitLab', 'DevOps']
description: 以實務步驟示範如何用 Helm 安裝 Argo CD，並結合 GitOps 與 GitLab SSO，讓多叢集 K8s 部署管理自動化又可回溯。
author: Mark Ku
---

## 前言：為什麼需要 Argo CD + GitOps？

想像一下這個場景：

- 你公司有 **10～20 個 Kubernetes 叢集**  
- 每次要更新服務，都要：
  - 切換 `kubectl context`
  - 找 YAML
  - `kubectl apply`
  - 再重複 10～20 次…

就好像你有 20 支手機，要裝同一個 App，結果你一支一支打開商店、搜尋、下載、登入——  
**很花時間，也很容易漏掉或按錯。**

**GitOps + Argo CD** 做的事情，就是：

- 把「你想要的叢集狀態」寫在 Git 裡（例如 YAML / Helm values）
- 讓 Argo CD 自動幫你把叢集同步成 Git 裡的樣子
- 所有歷史紀錄都在 Git 裡，要回滾也很簡單

缺點是，一開始你要先理解一些名詞：

- GitOps：宣告式、唯一真相來源（Single Source of Truth）
- Argo CD：Application、Project、Sync
- 週邊工具：Helm、OAuth (SSO)、Registry、RBAC…

但一旦這些概念串起來，**多叢集 + 多環境** 的日常維運會舒服非常多。

這篇文章會帶你一步一步完成三件事：

1. 先搞清楚：**Argo CD 在 GitOps 裡扮演什麼角色**  
2. 用 **Helm 安裝 Argo CD**，並補上最基本的設定  
3. 把 **GitLab SSO 串進來**，讓你用公司 GitLab 帳號登入 Argo CD

---

## 核心概念：先搞懂 GitOps 是什麼

### 什麼是 GitOps？（超白話版）

一句話版：

> **「把基礎設施當程式碼管，一切以 Git 為準。」**

展開一點大概是這樣：

- **Git 是唯一真相來源 (Single Source of Truth)**  
  - 所有 Kubernetes 設定檔（YAML、Helm values…）都放在 Git  
  - 想知道「現在這個環境應該長什麼樣子」→ 看 Git 就對了  

- **由系統自動 apply，不是人手 apply**  
  - 不是你下 `kubectl apply` 把東西推進去  
  - 而是由像 Argo CD 這種工具，**自己去 Git 抓設定**、自己幫你套用到叢集  

- **天然擁有版本控制與回滾能力**  
  - 誰改了什麼、什麼時候改，都有 commit log  
  - 若這次變更有問題，直接 Git revert 或切回前一版即可

可以用「煮菜」來比喻：

- 沒有 GitOps：每個人都憑感覺煮，**菜色很難一致**  
- 有 GitOps + Argo CD：大家都照同一份「食譜 (Git repo)」，  
  廚師（Argo CD）會一直檢查「成品」是不是跟食譜一樣，不一樣就自己調整回來。
   - **Name**：`ArgoCD SSO`
   - **Redirect URI**：`http://<your-node-ip>:32009/api/dex/callback`
   - **Scopes**：勾選 `openid`, `read_user`, `email`
3. 儲存後取得 **Application ID** 和 **Secret**

> ⚠️ 請妥善保存 Client ID 和 Secret，不要提交到 Git 倉庫中。

![](attachments/5a1836e9-f936-4e9c-9762-55b5eb67285e.png " =1548x674")

**兩種設定方式：**

**方案 A：透過 values.yaml 設定（建議）**
- 在後續 Step 4 中，將 Client ID 和 Secret 寫入 `values.yaml` 的 `dex.config` 區塊
- 安裝時一次到位，適合自動化部署

**方案 B：透過 UI 設定**
- 安裝後登入 Argo CD UI → `Settings → SSO / OAuth`
- 選擇 GitLab 並填寫 Client ID、Secret、Redirect URI
- 適合事後補強或調整設定

![](attachments/b8ce9bbd-f83d-4715-96e8-ca016638d3ef.png " =1874x907")

### Step 3：建立 GitLab Group Access Token

為了讓 Argo CD 能夠自動拉取 GitLab 上的程式碼和 Helm Chart，我們需要給它一把「讀取權限鑰匙」。Group Access Token 就是這把鑰匙，它可以讓 Argo CD 存取整個 GitLab Group 底下的所有專案，而不用每個 repo 都單獨設定一次。

1. 前往 GitLab Group → `Settings → Access Tokens`
2. 建立新 Token：
   - **Name**：`argocd-group-readonly`
   - **Scopes**：勾選 `read_repository` 和 `read_api`
   - **Role**：選擇 `Reporter`
3. 儲存後複製 Token（只會顯示一次）

### Step 4：配置 values.yaml

現在要把前面準備好的「通行證」（OAuth）和「讀取鑰匙」（Group Token）寫進 Argo CD 的設定檔裡。這個 `values.yaml` 就像是 Argo CD 的「身分證+通訊錄」，告訴它自己的對外網址是什麼、要怎麼跟 GitLab 溝通、可以存取哪些 repo。

編輯 `values.yaml`，整合所有設定：

```yaml
configs:
  cm:
    # Argo CD 對外 URL
    url: http://<your-node-ip>:32009
    
    # GitLab SSO 設定
    dex.config: |
      connectors:
        - type: gitlab
          id: gitlab
          name: GitLab
          config:
            baseURL: https://gitlab.example.com
            clientID: <your-gitlab-oauth-client-id>
            clientSecret: <your-gitlab-oauth-client-secret>
            redirectURI: http://<your-node-ip>:32009/api/dex/callback
    
  # GitLab Repository 認證（使用 Group Access Token）
  credentialTemplates:
    gitlab-group-token:
      url: https://gitlab.example.com
      username: oauth2
      password: <your-gitlab-group-access-token>
      
  # 預先註冊的 Repository
  repositories:
    kong-api-gateway:
      url: https://gitlab.example.com/your-group/kong-api-gateway.git
      type: git
    argocd-deployment:
      url: https://gitlab.example.com/your-group/argocd-deployment.git
      type: git

# Server 網路設定
server:
  service:
    type: NodePort
    nodePortHttp: 32009
    nodePortHttps: 32010
  
  # 允許 HTTP（僅開發環境使用）
  extraArgs:
    - --insecure
```

> 💡 **生產環境建議**：使用 Ingress + TLS 取代 NodePort，並移除 `--insecure` 參數。

### Step 5：執行安裝

設定檔準備好了，現在可以正式把 Argo CD 「蓋」到 Kubernetes 集群上。這個過程會建立所有必要的 Pod、Service、ConfigMap 等等，然後等它們全部啟動完成。就像蓋房子一樣，材料備齊了就開始施工，最後驗收確認能住人。

套用設定檔並安裝 Argo CD：

```bash
# 安裝 Argo CD
helm upgrade --install homelab-argo argo/argo-cd \
  --version 8.3.2 \
  -f values.yaml \
  -n argocd --create-namespace

# 等待 Pod 就緒
kubectl wait --for=condition=ready pod \
  -l app.kubernetes.io/name=argocd-server \
  -n argocd --timeout=300s

# 取得初始 admin 密碼
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d
```

登入後請立即修改 admin 密碼。

---

## 權限管理

### Step 6：設定 RBAC 與 AppProject

Argo CD 安裝好了，但現在它還不知道「可以管哪些資源」、「可以部署到哪些地方」。AppProject 就像是一份「授權清單」，明確定義 Argo CD 可以碰哪些 Kubernetes 資源、可以連到哪些集群、可以存取哪些 Git repo。沒有這個授權，Argo CD 就會因為權限不足而無法正常工作。

安裝完成後，需要配置 AppProject 來管理應用程式的權限範圍。

建立 `argocd-projects.yaml`：

```yaml
apiVersion: v1
kind: List
items:
# Default Project - 基本權限
- apiVersion: argoproj.io/v1alpha1
  kind: AppProject
  metadata:
    name: default
    namespace: argocd
  spec:
    # 允許所有來源 repo
    sourceRepos:
    - '*'
    
    # 允許部署到所有叢集與 namespace
    destinations:
    - namespace: '*'
      server: '*'
    
    # 允許操作集群級資源
    clusterResourceWhitelist:
    - group: '*'
      kind: '*'
    
    # 允許操作命名空間級資源
    namespaceResourceWhitelist:
    - group: '*'
      kind: '*'

# 自訂 Project - 依需求調整
- apiVersion: argoproj.io/v1alpha1
  kind: AppProject
  metadata:
    name: your-project
    namespace: argocd
  spec:
    description: 你的專案描述
    
    sourceRepos:
    - 'https://gitlab.example.com/your-group/*'
    
    destinations:
    - namespace: '*'
      server: https://kubernetes.default.svc
    
    # 集群級資源白名單
    clusterResourceWhitelist:
    - group: ''
      kind: Namespace
    - group: 'rbac.authorization.k8s.io'
      kind: ClusterRole
    - group: 'rbac.authorization.k8s.io'
      kind: ClusterRoleBinding
    - group: 'apiextensions.k8s.io'
      kind: CustomResourceDefinition
    
    # 命名空間級資源白名單
    namespaceResourceWhitelist:
    - group: ''
      kind: ConfigMap
    - group: ''
      kind: Secret
    - group: ''
      kind: Service
    - group: ''
      kind: ServiceAccount
    - group: 'apps'
      kind: Deployment
    - group: 'apps'
      kind: StatefulSet
    - group: 'batch'
      kind: Job
    - group: 'batch'
      kind: CronJob
    - group: 'networking.k8s.io'
      kind: Ingress

# Argo CD Controller 額外的 RBAC 權限（支援 metrics-server 等）
- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    name: argocd-application-controller-auth-delegator
    labels:
      app.kubernetes.io/component: application-controller
      app.kubernetes.io/name: argocd-application-controller
      app.kubernetes.io/part-of: argocd
  rules:
  # Auth delegation for metrics-server
  - apiGroups: ["authentication.k8s.io"]
    resources: ["tokenreviews"]
    verbs: ["create"]
  - apiGroups: ["authorization.k8s.io"]
    resources: ["subjectaccessreviews"]
    verbs: ["create"]
  # API Services management
  - apiGroups: ["apiregistration.k8s.io"]
    resources: ["apiservices"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]

- apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    name: argocd-application-controller-auth-delegator
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: argocd-application-controller-auth-delegator
  subjects:
  - kind: ServiceAccount
    name: argocd-application-controller
    namespace: argocd
```

### 套用設定

```bash
# 套用 AppProject 與 RBAC 設定
kubectl apply -f argocd-projects.yaml -n argocd

# 驗證 Project 是否建立成功
kubectl get appprojects -n argocd

# 驗證 RBAC 是否建立成功
kubectl get clusterrole | grep argocd
kubectl get clusterrolebinding | grep argocd
```

### 理解權限架構

Argo CD 與 GitLab 整合涉及三層權限管理：

**1. SSO 登入（GitLab OAuth）**
- 控制使用者身分驗證與授權
- 決定誰可以存取 Argo CD UI 及可見的 Application 範圍
- 本文已在 Step 4 的 `values.yaml` 中完成設定

**2. Repository 存取（Group Access Token）**
- 讓 Argo CD 讀取 GitLab 倉庫的程式碼與 Helm Chart
- 採用 Group Access Token 統一管理整個 Group 的權限
- 已在 Step 4 的 `credentialTemplates` 中完成設定

**3. Container Registry（選用）**
- 若使用 GitLab Container Registry 拉取映像檔，需額外設定
- 可使用 Deploy Token 建立 `imagePullSecrets`

> 💡 **簡單記憶**：SSO 管「人」，Group Token 管「程式碼」，Registry Token 管「映像檔」。

![](attachments/b8ce9bbd-f83d-4715-96e8-ca016638d3ef.png " =1874x907")

---

## 實戰範例

### 應用程式狀態總覽

圖表說明 ![](attachments/37293e96-21b9-4734-b8b8-8f657ecd65e6.png)

這張圖片是 [Argo CD](https://argo-cd.readthedocs.io/en/stable/) 的應用程式狀態畫面，用來管理 Kubernetes 應用程式的部署狀態：


* **應用程式名稱：** `testapp`
* **APP HEALTH（健康狀態）：** ✅ **Healthy** → 代表應用程式目前的所有資源都運作正常。
* **SYNC STATUS（同步狀態）：** ✅ **Synced to HEAD (d227ef5)** → 表示 Git 倉庫裡的設定檔已成功同步到叢集，沒有偏差。
* **LAST SYNC：** ✅ **Sync OK** → 最近一次同步成功，是在 `18 hours ago`（18 小時前）由 `mark.ku` 完成的。 → 提交備註為 `update config`。
* **Auto sync：** ❌ **未啟用自動同步**（Auto sync is not enabled）


---

### 🌳 應用程式資源架構圖解

這是以 GitOps 模式部署的 Kubernetes 應用資源樹狀圖：


1. **testapp（應用程式）**
   * **nginx-content（ConfigMap）**
   * **test-app（Namespace）**
   * **nginx-test-service（Service）**
   * **nginx-test（Deployment）**
     * **nginx-test-554867cd4b（ReplicaSet）**
       * **nginx-test-554867cd4b-65gtp（Pod）**
       * **nginx-test-554867cd4b-xgs9x（Pod）**

📌 所有資源右上角都有 ✅，表示部署成功、狀態正常。

---

## 常用指令參考

### Helm 相關

```bash
# 安裝 Helm（Windows）
choco install kubernetes-helm

# 安裝/升級 Argo CD
helm upgrade --install argocd argo/argo-cd \
  --namespace argocd --create-namespace \
  -f values.yaml

# 匯出當前設定
helm get values argocd -n argocd -o yaml > current-values.yaml
```

### Kubernetes 相關

```bash
# 查詢 Argo CD Service
kubectl get svc argocd-server -n argocd

# 將 Service 改為 NodePort
kubectl patch svc argocd-server -n argocd -p '{
  "spec": {
    "type": "NodePort",
    "ports": [
      {
        "port": 80,
        "targetPort": 8080,
        "nodePort": 32009
      }
    ]
  }
}'

# 取得初始 admin 密碼
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d

# 匯出 AppProject 設定
kubectl get appprojects -n argocd -o yaml > argocd-projects.yaml
```

> ⚠️ 取得 admin 密碼後，請立即登入並修改密碼以確保安全。

---

## 總結

透過本文，您已經完成：

1. ✅ 理解 GitOps 與 Argo CD 的核心概念
2. ✅ 使用 Helm 完整安裝與配置 Argo CD
3. ✅ 整合 GitLab SSO 實現安全的身分驗證
4. ✅ 使用 Group Access Token 管理倉庫存取權限
5. ✅ 設定 RBAC 與 AppProject 控制資源權限

**下一步建議**：

- 建立您的第一個 Application，實際體驗 GitOps 工作流程
- 啟用自動同步功能，實現完全自動化部署
- 整合 CI/CD Pipeline，建立完整的 DevOps 流程
- 在生產環境中配置 Ingress + TLS，提升安全性

## 參考資料

- [Argo CD 官方文件](https://argo-cd.readthedocs.io/)
- [Argo CD Helm Chart](https://github.com/argoproj/argo-helm)
- [GitLab OAuth 設定](https://docs.gitlab.com/ee/integration/oauth_provider.html)
- [Argo CD 實作範例](https://blog.csdn.net/cr7258/article/details/122028096)
- [GitOps 最佳實踐](https://ithelp.ithome.com.tw/articles/10266761)