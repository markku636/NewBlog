---
featured: true
title: 深入探討 Vibe Coding 限制
slug: vibe-coding-limitations
category: AI
thumbnail: vibe-coding-limitations.png
date: 2025-08-06 06:01:00 +0800
tags: ['AI', 'Coding', 'Development', 'Vibe Coding', 'Software Engineering', 'Productivity']
description: 深入探討 Vibe Coding 的七大限制，包含具體例子和實用見解，幫助開發者更好地理解 AI 輔助編程的現狀與挑戰。
author: Mark Ku
---

## Vibe Coding 的興起與挑戰

隨著 AI 程式輔助工具的普及，許多開發者開始嘗試「Vibe coding」——也就是給 AI 一些簡單的描述或方向，讓它自動生成程式碼。雖然這種方式能夠快速生產新的程式碼，但在實際專案開發中仍有不少限制。

**Vibe coding 的核心概念**是透過自然語言描述需求，讓 AI 自動生成對應的程式碼。這種方法在原型開發、快速驗證想法時確實很有用，但在面對複雜的企業級專案時，往往會遇到各種挑戰。

## 1️⃣ 在既有複雜性上疊加功能是挑戰

AI 可以快速產生新的程式碼模組，但當需要把新功能整合進已有的複雜系統時，問題就會浮現。

### 具體例子：電商系統的動態折扣功能

```javascript
// AI 生成的折扣計算模組
class DiscountCalculator {
    calculateDiscount(order, rules) {
        let totalDiscount = 0;
        for (const rule of rules) {
            if (this.evaluateRule(order, rule)) {
                totalDiscount += rule.discount;
            }
        }
        return totalDiscount;
    }
    
    evaluateRule(order, rule) {
        // 簡單的規則評估邏輯
        return order.total >= rule.minAmount;
    }
}
```

**問題所在：**
- AI 無法理解現有的訂單流程中，折扣計算會影響庫存檢查
- 沒有考慮到付款驗證時需要重新計算總金額
- 忽略了多種折扣規則可能產生的衝突

**實際整合時的問題：**
```javascript
// 現有的訂單處理流程
class OrderProcessor {
    async processOrder(order) {
        // 1. 檢查庫存
        await this.checkInventory(order.items);
        
        // 2. 計算折扣（新功能）
        const discount = this.discountCalculator.calculateDiscount(order, this.discountRules);
        order.total -= discount; // 這裡可能影響後續的庫存檢查邏輯
        
        // 3. 驗證付款
        await this.validatePayment(order.total); // 總金額已經被修改
        
        // 4. 更新庫存
        await this.updateInventory(order.items); // 可能因為折扣影響庫存計算
    }
}
```

## 2️⃣ 冷門且複雜的新問題時，AI 經常答不上來

AI 的能力依賴於過往訓練資料，如果問題冷門或涉及全新概念，它往往無法提供完整解法。

### 具體例子：區塊鏈交易驗證演算法

```javascript
// AI 可能給出的模糊方向
class TransactionValidator {
    validateTransaction(transaction) {
        // AI 只能提供基本的驗證
        if (this.checkBasicFormat(transaction)) {
            return this.basicValidation(transaction);
        }
        return false;
    }
    
    checkBasicFormat(transaction) {
        // 簡單的格式檢查邏輯
        return transaction.hash && transaction.signature;
    }
}
```

**實際需求：**
- 需要處理多種加密貨幣的複雜驗證規則
- 必須考慮雙重支付攻擊防護
- 需要自適應的共識機制驗證

**AI 的限制：**
- 缺乏區塊鏈技術的專業知識
- 無法理解不同加密貨幣的差異
- 只能提供通用的解決方案框架

## 3️⃣ 腦容量（Context）有限，難以處理超大型專案

再強大的 AI 也有上下文限制，能同時「記住」的程式碼量有限，超過後就無法全盤理解。

### 具體例子：200,000 行程式碼的金融系統

```javascript
// AI 只能看到部分程式碼，無法理解整體架構
class FinancialSystem {
    // 這裡可能有數千行複雜的業務邏輯
    // AI 無法同時處理所有相關模組
}

class RiskManagement {
    // 風險管理模組
    // AI 可能不知道這個模組與其他模組的互動
}

class ComplianceEngine {
    // 合規檢查引擎
    // AI 無法理解複雜的業務規則和依賴關係
}
```

**實際問題：**
- AI 只能看到當前對話中的程式碼片段
- 無法理解模組間的複雜依賴關係
- 缺乏對整體架構的認知

## 4️⃣ 實作複雜功能時聯想力不足，容易「改 A 壞 B」

AI 在理解系統內部相依性時仍有不足，缺乏人類工程師能從經驗中建立的直覺。

### 具體例子：稅率計算函式的修改

```javascript
// 原始稅率計算函式
class TaxCalculator {
    calculateTax(amount, region) {
        const rate = this.getTaxRate(region);
        const tax = amount * rate;
        
        // 同時更新報表模組的統計資料
        this.updateReportStatistics(amount, tax, region);
        
        return tax;
    }
    
    updateReportStatistics(amount, tax, region) {
        // 這個方法被多個報表模組依賴
        this.reportEngine.addTransaction(amount, tax, region);
    }
}

// AI 修改後的版本（可能破壞報表功能）
class TaxCalculator {
    calculateTax(amount, region) {
        const rate = this.getTaxRate(region);
        const tax = amount * rate;
        
        // AI 可能移除或修改這行，導致報表錯誤
        // this.updateReportStatistics(amount, tax, region);
        
        return tax;
    }
}
```

**問題後果：**
- 稅率計算正確，但報表資料不完整
- 財務報表出現錯誤
- 審計時發現資料不一致

## 5️⃣ 記憶缺陷，難以重用已教過的方法

AI 在單次對話中能學習指引，但長期記憶不足，導致無法重用過往解法。

### 具體例子：排序演算法的最佳化

```javascript
// 昨天教會 AI 的最佳化排序演算法
class OptimizedSorter {
    sort(array) {
        // 使用快速排序 + 插入排序的混合策略
        if (array.length < 10) {
            return this.insertionSort(array);
        }
        
        const pivot = this.choosePivot(array);
        const { left, right } = this.partition(array, pivot);
        
        return [
            ...this.sort(left),
            pivot,
            ...this.sort(right)
        ];
    }
    
    choosePivot(array) {
        // 三數取中法選擇樞軸
        const mid = Math.floor(array.length / 2);
        const first = array[0];
        const last = array[array.length - 1];
        const middle = array[mid];
        
        return this.medianOfThree(first, middle, last);
    }
}

// 今天再問類似需求時，AI 可能完全忘記，重新產生一個效率更差的版本
class BasicSorter {
    sort(array) {
        // 簡單的氣泡排序，效率較差
        for (let i = 0; i < array.length; i++) {
            for (let j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    [array[j], array[j + 1]] = [array[j + 1], array[j]];
                }
            }
        }
        return array;
    }
}
```

## 6️⃣ 模型切換造成品質不穩

許多開發環境中，使用高階模型（例如 GPT-4.5）寫一部分程式碼後，為了省成本改用低階模型接續開發，結果程式碼品質大幅下降。

### 具體例子：API 設計的一致性問題

```javascript
// 高階模型設計的 API
class UserService {
    async createUser(userData) {
        // 完整的驗證邏輯
        const validatedData = await this.validateUserData(userData);
        
        // 業務邏輯處理
        const user = await this.userRepository.create(validatedData);
        
        // 事件發布
        await this.eventBus.publish('user.created', { userId: user.id });
        
        return user;
    }
    
    async validateUserData(data) {
        const schema = Joi.object({
            email: Joi.string().email().required(),
            password: Joi.string().min(8).required(),
            name: Joi.string().min(2).required()
        });
        
        return await schema.validateAsync(data);
    }
}

// 低階模型維護時可能產生的問題
class UserService {
    async createUser(userData) {
        // 簡化的驗證，可能遺漏重要檢查
        if (!userData.email || !userData.password) {
            throw new Error('Missing required fields');
        }
        
        // 直接創建，沒有事件發布
        const user = await this.userRepository.create(userData);
        
        return user;
    }
    
    // 可能重複造輪子，而不是重用現有的驗證邏輯
    async validateEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    }
}
```

## 7️⃣ 風格與設計不一致

除非明確告訴 AI 應遵循哪些架構原則和命名規則，否則每次產出的程式碼風格都可能不同。

### 具體例子：登入功能的架構不一致

```javascript
// 第一次：使用 MVC 架構
class LoginController {
    async login(req, res) {
        try {
            const { email, password } = req.body;
            const user = await this.userService.authenticate(email, password);
            
            if (user) {
                const token = this.authService.generateToken(user);
                res.json({ success: true, token });
            } else {
                res.status(401).json({ success: false, message: 'Invalid credentials' });
            }
        } catch (error) {
            res.status(500).json({ success: false, message: error.message });
        }
    }
}

// 第二次：使用函式式設計
const loginUser = async (email, password) => {
    const validateCredentials = (email, password) => {
        if (!email || !password) {
            throw new Error('Email and password are required');
        }
    };
    
    const authenticateUser = async (email, password) => {
        const user = await findUserByEmail(email);
        if (user && await verifyPassword(password, user.password)) {
            return user;
        }
        return null;
    };
    
    validateCredentials(email, password);
    const user = await authenticateUser(email, password);
    
    if (user) {
        const token = generateJWT(user);
        return { success: true, token };
    } else {
        throw new Error('Invalid credentials');
    }
};
```

## 上述問題部份可以透過Cursor 指南和 Copilot 指南解決

### 1. Cursor 使用指南

Cursor 作為基於 AI 的程式碼編輯器，能夠大幅提升開發效率，但需要正確的使用策略。

#### 建立專案上下文檔案

**檔案位置：** 專案根目錄  
**檔名：** `.cursorrules`

```javascript
// .cursorrules 檔案範例
const cursorRules = {
    project: {
        name: 'E-commerce Platform',
        architecture: 'Clean Architecture',
        language: 'TypeScript',
        framework: 'Next.js',
        database: 'PostgreSQL'
    },
    coding: {
        style: 'camelCase',
        errorHandling: 'try-catch with custom errors',
        validation: 'Zod schemas',
        testing: 'Jest + React Testing Library'
    },
    ai: {
        context: 'Always consider existing codebase patterns',
        documentation: 'Include JSDoc comments',
        testing: 'Generate unit tests for new functions'
    }
};
```

**建立步驟：**
1. 在專案根目錄建立 `.cursorrules` 檔案
2. 複製上述範例並根據專案需求修改
3. 儲存檔案後，Cursor 會自動讀取並應用這些設定

#### 有效的 Cursor 提示技巧

```javascript
// 提供完整上下文的提示範例
const effectivePrompt = `
請根據以下專案規範生成程式碼：

專案架構：Clean Architecture
程式語言：TypeScript
框架：Next.js
資料庫：PostgreSQL

要求：
1. 遵循現有的命名規範（camelCase）
2. 包含完整的錯誤處理
3. 添加 JSDoc 註解
4. 生成對應的單元測試
5. 考慮與現有模組的整合

現有相關程式碼：
${existingCodeContext}
`;
```

### 2. GitHub Copilot 使用指南

GitHub Copilot 作為程式碼補全工具，能夠提供即時的程式碼建議，但需要正確的配置和使用方法。

#### 建立 Copilot 設定檔案

**檔案位置：** 專案根目錄下的 `.copilot` 資料夾  
**檔名：** `settings.json`

```javascript
// .copilot/settings.json
{
    "project": {
        "name": "E-commerce Platform",
        "type": "web-application",
        "stack": ["TypeScript", "Next.js", "PostgreSQL", "Redis"]
    },
    "coding": {
        "style": {
            "naming": "camelCase",
            "indentation": "spaces",
            "quotes": "single"
        },
        "patterns": {
            "errorHandling": "try-catch with custom error classes",
            "validation": "Zod schemas",
            "async": "async/await with proper error handling"
        }
    },
    "ai": {
        "context": "Consider existing codebase patterns and conventions",
        "documentation": "Always include JSDoc comments",
        "testing": "Generate unit tests for new functionality"
    }
}
```

**建立步驟：**
1. 在專案根目錄建立 `.copilot` 資料夾
2. 在 `.copilot` 資料夾內建立 `settings.json` 檔案
3. 複製上述範例並根據專案需求修改
4. 儲存檔案後，Copilot 會自動讀取並應用這些設定

#### 專案檔案結構總結

```
your-project/
├── .cursorrules                    # Cursor 專案上下文檔案
├── .copilot/                       # Copilot 設定資料夾
│   └── settings.json              # Copilot 設定檔案
├── src/                           # 專案原始碼
├── tests/                         # 測試檔案
├── docs/                          # 專案文件
└── package.json                   # 專案依賴
```

**重要提醒：**
- `.cursorrules` 和 `.copilot` 資料夾都應該加入版本控制
- 這些檔案會影響團隊所有成員的 AI 工具行為
- 建議在團隊中統一這些設定檔案的格式和內容

#### Copilot 最佳實踐

```javascript
// 使用 Copilot 時的程式碼註解範例
/**
 * 創建新用戶帳戶
 * @param {Object} userData - 用戶資料物件
 * @param {string} userData.email - 用戶電子郵件
 * @param {string} userData.password - 用戶密碼
 * @param {string} userData.name - 用戶姓名
 * @returns {Promise<Object>} 創建的用戶物件
 * @throws {ValidationError} 當資料驗證失敗時
 * @throws {DuplicateUserError} 當用戶已存在時
 */
async function createUserAccount(userData) {
    // Copilot 會根據註解和上下文生成相應的程式碼
    // 包含驗證、錯誤處理、資料庫操作等
}

// 使用 Copilot 生成測試程式碼
/**
 * 測試用戶帳戶創建功能
 * 測試案例：
 * 1. 成功創建新用戶
 * 2. 重複電子郵件應該失敗
 * 3. 無效資料應該拋出驗證錯誤
 */
describe('createUserAccount', () => {
    // Copilot 會根據描述生成測試案例
});
```

### 3. 整合使用策略

#### 建立開發工作流程

```javascript
// 開發工作流程配置
const developmentWorkflow = {
    planning: {
        tool: 'Cursor',
        purpose: '架構設計和程式碼生成',
        context: '提供完整的專案上下文和需求描述'
    },
    implementation: {
        tool: 'Copilot',
        purpose: '即時程式碼補全和建議',
        context: '在現有程式碼基礎上進行開發'
    },
    review: {
        tool: 'Cursor',
        purpose: '程式碼審查和重構',
        context: '分析程式碼品質和架構一致性'
    }
};

// 使用範例
const workflowExample = `
1. 使用 Cursor 進行功能設計：
   - 提供詳細的需求描述
   - 包含現有程式碼上下文
   - 指定架構和設計模式

2. 使用 Copilot 進行實作：
   - 在現有檔案中編寫程式碼
   - 利用註解引導 Copilot
   - 接受或拒絕建議

3. 使用 Cursor 進行優化：
   - 程式碼重構和優化
   - 添加測試和文件
   - 確保程式碼品質
`;
```

#### 常見問題解決方案

```javascript
// 解決 Copilot 建議不準確的問題
const copilotOptimization = {
    problem: 'Copilot 建議的程式碼不符合專案規範',
    solution: {
        step1: '在檔案頂部添加詳細的註解說明專案規範',
        step2: '使用一致的命名和程式碼風格',
        step3: '提供足夠的上下文資訊'
    }
};

// 解決 Cursor 上下文限制的問題
const cursorOptimization = {
    problem: 'Cursor 無法理解大型專案的完整架構',
    solution: {
        step1: '建立專案架構文件',
        step2: '使用 .cursorrules 檔案定義專案規範',
        step3: '分模組進行開發和討論'
    }
};
```

## 結論

Vibe coding 雖然能夠快速生成程式碼、加速原型開發，但在面對大型專案、複雜邏輯、長期維護時，AI 仍難以完全取代工程師，人類工程師能夠全盤理解系統架構、具備長期記憶、解決未知問題並保證程式風格一致，這些都是當前 AI 仍無法完全做到的。

透過正確使用 Cursor 和 Copilot 等 AI 工具，開發者可以大幅提升開發效率，但關鍵在於建立正確的使用策略和工作流程，讓 AI 成為工程師的得力助手，而不是完全依賴的替代品。

